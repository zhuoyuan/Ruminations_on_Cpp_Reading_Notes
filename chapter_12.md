
### 设计容器类

*容器是一种保存对象集合的数据结构. C有两种内建容器：数组和结构体. C++本来可以提供给用户更多的容器，但是没有，不过C++提供给用户写自己的容器的方法*

在动手写下我们的第一个容器类前，首先我们应该考虑一下我们可能遇到的问题

##### **包含什么**

容器应该包含对象，那么包含的意义是什么，当我们写下
```
Object obj;
c.insert(obj);
```
时，我们放入的是obj本身呢，还是obj的一个副本？稍作思考，放入obj本身行不通，一旦obj被释放，容器又不知道，有安全隐患

##### **复制容器意味着什么**

在回答这个问题前，我们考虑一下内建容器是怎么做的，对于数组，内建数组不允许复制,很遗憾，内建数组没能帮助我们. 不过从使用的角度考虑问题可能更有帮助，通常复制发生在函数传参和函数返回，对于传参，可以用指针或引用，因此好像也没有复制的问题，关键在于返回，函数返回后，局部容器已经被释放了，提示我们应该使用值语义.

*需要指出，和作者一样，这个观点掺杂了个人见解，并不绝对*

##### **怎么获取容器的元素**

当我们从容器中取出一个对象时，应该获取对象的引用吗？当我们写下x[i] = x[j]时，如果i > size,又会发生什么？

##### **怎样区分读和写**

如果[]运算符只用来取数，那么上一个问题就不存在了，但这样会带来其它问题:
```
Container<Ccontainer<int>> c;
k = c[i][j];
//如何更新c[i][j] ?
```
或者我们可以定义一个updata函数负责写操作，但是这样也让我们失去了包含容器的容器的能力，所以这样看来还是应该允许[]获取引用，只是必须提醒用户只能在创建了引用之后才能使用他们

##### **怎样处理容器的增长**

1. 既然我们没有把存储和取出的操作分开，那么保存对象和取出对象时，容器的表现也应该一致，一种合理的方式是提供一种手段显式创建新的元素，当有人试图在没有创建元素前就访问该元素时抛出异常
2. 应该按区块增加容器的大小，应该谨慎选择适当的增长因子

##### **容器支持那些操作**

1. 是否支持“多维数组(容器包含容器)”
2. 如何“顺序的”遍历容器的元素

##### **怎样设想容器元素的类型**

1. 我们前面讨论过，应该复制容器的元素，这个结论提示我们：
- 我们可以复制类型为T的元素
- 元素复制的行为要进行正确的选择(这意味着对类型T有一定的要求)

2. 类型T应该提供判断关系判断操作符
3. 类型T能够输入输出

*除了以上几种要求外，对类型T的其它额外要求都会降低容器的通用性，应该根据容器的用途来决定T应该具备怎么样的操作*

##### **容器和继承**

通常来说，容器和继承不能混用
我们能让Container<Airplane>继承自Container<Vehicle>吗？
```
Vehicle v;
Container<Airplane> ca;
Container<Vehicle>& vp = ca; // 面向对象编程
vp.insert(v);
```
这样使我们可以向Container<Airplane>中插入一个普通的Vehicle，等到这个容器中所有的Vehicle一起飞翔时，那就太“壮观”了

实际上，如果要把继承用于容器，那么Container<Vehicle>就必须继承自Container<Airplane>，而且，Container<Vehicle>还应该继承自所有的Container<V>, V继承自Vehicle，这个推理让我们信服，不同类型的容器不应该存在继承关系，Container<Airplane>和Container<Vehicle>应该是完全不同的类.

##### **设计一个类似数组的容器**

[SourceCode](./Code/chapter_12_Array.cpp)

上述代码至少有两个缺陷：

- 包含元素的Array消失后，他的元素地址还存在
- 允许用户访问他的元素的地址，违背封装的概念

此外，如果要扩展这个类，比如允许Array类倍构造后可以改变长度，我们似乎只需要增加一个resize的函数即可，但是仔细想想，这个函数该如何工作，它可能要为新元素分配内存，从旧元素复制值给它们，然后释放原来的内存，但是这里隐藏了一个缺陷，**内存地址的变化可能会使所有指向它的任何元素的地址失效**

372463
